# فاز دوم: کنترل روشنایی هوشمند و خودکار

در این فاز، پروژه دیمر را از یک کنترلر صرفاً دستی به یک سیستم روشنایی تطبیقی هوشمند ارتقا می‌دهیم. هدف اصلی، افزودن یک حالت خودکار است که در آن، روشنایی لامپ بر اساس نور محیط تنظیم می‌شود، در حالی که کاربر همچنان قابلیت کنترل دستی را در هر زمان خواهد داشت.

---

## قطعات جدید و تغییرات سخت‌افزاری

برای دستیابی به این قابلیت، تنها یک قطعه کلیدی به مدار اضافه شده است: سنسور LDR.

### سنسور LDR (فتورزیستور)

LDR یا مقاومت وابسته به نور، به عنوان "چشم" الکترونیکی مدار ما عمل می‌کند. این قطعه یک مقاومت متغیر است که مقدار آن با شدت نور تابیده شده به سطحش، رابطه معکوس دارد:

* **در تاریکی:** مقاومت آن بسیار بالا است (در حد مگا اهم).
* **در روشنایی:** مقاومت آن به شدت کاهش می‌یابد (در حد چند کیلو اهم یا کمتر).

#### نحوه استفاده در مدار

پین آنالوگ آردوینو ولتاژ را می‌خواند، نه مقاومت. بنابراین برای اینکه بتوانیم تغییرات مقاومت LDR را اندازه‌گیری کنیم، آن را در یک مدار ساده **تقسیم ولتاژ (Voltage Divider)** قرار می‌دهیم.

**اتصالات:**
1.  یک پایه LDR به 5V متصل می‌شود.
2.  پایه دیگر LDR به پین آنالوگ A1 آردوینو متصل می‌گردد.
3.  یک مقاومت ثابت 10kΩ از همان پین A1 به GND وصل می‌شود.

---

## کالیبراسیون سنسور LDR

برای اینکه حالت خودکار به درستی کار کند، باید به آردوینو "یاد بدهیم" که در مدار ما، منظور از "تاریک" و "روشن" دقیقاً چه محدوده‌ای از مقادیر است. این فرآیند کالیبراسیون نام دارد.

### گام اول: پیدا کردن محدوده ولتاژ

ما با استفاده از پروب ولتاژ (Voltage Probe) در پروتئوس، ولتاژ پین A1 را در دو حالت حدی اندازه‌گیری کردیم:

1.  **حالت تاریک:** با دور کردن مشعل از LDR، حداکثر ولتاژ خوانده شده حدود **4.76V** بود.
2.  **حالت روشن:** با نزدیک کردن مشعل به LDR، حداقل ولتاژ خوانده شده حدود **0.05V** بود.

### گام دوم: تبدیل ولتاژ به مقادیر `analogRead`

تابع `analogRead()` آردوینو ولتاژ ورودی 0 تا 5 ولت را به یک عدد صحیح بین 0 تا 1023 تبدیل می‌کند. بنابراین:

* **مقدار آنالوگ در تاریکی:** `(4.76 / 5.0) * 1023 ≈ 975`
* **مقدار آنالوگ در روشنایی:** `(0.05 / 5.0) * 1023 ≈ 10`

پس محدوده کاری دقیق سنسور ما در این مدار بین **10 (روشن‌ترین حالت)** و **975 (تاریک‌ترین حالت)** است.

---

## منطق جدید نرم‌افزار: حالت دوگانه خودکار/دستی

برای افزودن قابلیت کنترل هوشمند، قلب برنامه یعنی تابع `loop()` را به یک مدیر وضعیت هوشمند تبدیل می‌کنیم. این مدیر وظیفه دارد بین دو حالت خودکار (Automatic) و دستی (Manual) جابجا شده و تصمیم بگیرد که کنترل روشنایی لامپ بر عهده کدام ورودی (LDR یا پتانسیومتر) باشد.

این منطق بر اساس سه قانون اصلی کار می‌کند:

### ۱. فعال‌سازی حالت دستی

برنامه به طور مداوم مقدار پتانسیومتر را می‌خواند و با مقدار قبلی مقایسه می‌کند. اگر تغییر مقدار از یک آستانه کوچک (مثلاً 10 واحد) بیشتر باشد، برنامه این را به عنوان یک دخالت عمدی از سوی کاربر تلقی می‌کند. در این لحظه:

* یک پرچم (`isManualMode`) به حالت `true` درمی‌آید تا سیستم وارد حالت دستی شود.
* زمان فعلی به عنوان "زمان آخرین تنظیم دستی" (`lastManualAdjustmentTime`) ذخیره می‌شود. این کار، شمارشگر زمان برای بازگشت به حالت خودکار را ریست می‌کند.

### ۲. بازگشت خودکار با Timeout ⏳

هنگامی که سیستم در حالت دستی قرار دارد، برنامه در هر تکرار حلقه `loop()`، زمان سپری شده از آخرین تنظیم دستی را محاسبه می‌کند.

* این کار با کم کردن `lastManualAdjustmentTime` از زمان فعلی (`millis()`) انجام می‌شود.
* اگر این اختلاف زمانی از مقدار تعیین شده برای Timeout (مثلاً ۱۰۰۰۰ میلی‌ثانیه یا ۱۰ ثانیه) بیشتر شود، برنامه به این نتیجه می‌رسد که کاربر دیگر قصد تنظیم دستی ندارد.
* در نتیجه، پرچم `isManualMode` به حالت `false` برگردانده شده و سیستم به آرامی به حالت خودکار بازمی‌گردد.

### ۳. تعیین مقدار نهایی کنترل 💡

در نهایت، یک بلوک `if/else` ساده تصمیم می‌گیرد که کدام مقدار به عنوان ورودی نهایی برای محاسبه روشنایی لامپ استفاده شود:

* اگر `isManualMode` برابر `true` باشد: مقدار خوانده شده از پتانسیومتر به عنوان `controlValue` در نظر گرفته می‌شود.
* اگر `isManualMode` برابر `false` باشد: مقدار خوانده شده از سنسور LDR (پس از map) به عنوان `controlValue` استفاده می‌شود.

این مقدار `controlValue` نهایی، صرف نظر از منشأ آن، برای محاسبه `dimmingDelay` به کار رفته و روشنایی لامپ را تنظیم می‌کند. این ساختار یک تجربه کاربری روان و هوشمند را فراهم می‌کند که در آن، کنترل همیشه در دسترس کاربر است اما در صورت عدم دخالت، سیستم به طور خودکار عمل می‌کند.

---

## منطق کنترلی به زبان دیاگرام حالت

سیستم ما همیشه در یکی از دو حالت زیر قرار دارد. رویدادهای خاصی باعث انتقال (Transition) بین این حالت‌ها می‌شوند.

### حالت ۱: کنترل خودکار (AUTO_MODE)

این حالت پیش‌فرض و هوشمند سیستم است.

* **اقدام در این حالت:** روشنایی لامپ بر اساس مقدار سنسور LDR تنظیم می‌شود.
* **انتقال به حالت دستی:**
    * **رویداد:** کاربر پتانسیومتر را می‌چرخاند.
    * **شرط:** تغییر مقدار پتانسیومتر > آستانه (Threshold)
    * **عملیات:**
        1.  زمان فعلی به عنوان "آخرین زمان تنظیم" ثبت می‌شود.
        2.  سیستم به حالت دستی منتقل می‌شود.
    * **انتقال:** `AUTO_MODE -> MANUAL_MODE`

### حالت ۲: کنترل دستی (MANUAL_MODE)

در این حالت، کنترل کامل در اختیار کاربر است.

* **اقدام در این حالت:** روشنایی لامپ بر اساس مقدار پتانسیومتر تنظیم می‌شود.
* **انتقال‌ها از این حالت:**
    1.  **باقی ماندن در حالت دستی:**
        * **رویداد:** کاربر پتانسیومتر را دوباره می‌چرخاند.
        * **شرط:** تغییر مقدار پتانسیومتر > آستانه
        * **عملیات:**
            1.  تایمر Timeout ریست می‌شود (زمان فعلی به عنوان "آخرین زمان تنظیم" ثبت می‌گردد).
            2.  سیستم در حالت دستی باقی می‌ماند.
        * **انتقال:** `MANUAL_MODE -> MANUAL_MODE`
    2.  **بازگشت به حالت خودکار:**
        * **رویداد:** کاربر برای مدتی با پتانسیومتر کار نمی‌کند.
        * **شرط:** (زمان فعلی - آخرین زمان تنظیم) > Timeout (مثلاً ۱۰ ثانیه)
        * **عملیات:**
            1.  سیستم به حالت خودکار منتقل می‌شود.
        * **انتقال:** `MANUAL_MODE -> AUTO_MODE`

---

## عیب‌یابی شبیه‌سازی: مدیریت خطاهای SPICE در پروتئوس

شبیه‌سازی مدارهای ترکیبی آنالوگ-دیجیتال که شامل سوئیچینگ سریع هستند (مانند دیمر)، می‌تواند برای موتور شبیه‌سازی SPICE چالش‌برانگیز باشد و منجر به خطاهایی مانند `Timestep too small` یا `Simulation is not running in real time` شود. این خطاها نشان می‌دهند که شبیه‌ساز در حل معادلات ریاضی مدار در یک لحظه خاص دچار مشکل شده است.

### مشکل احتمالی: ناپایداری محاسباتی

منشأ اصلی این خطاها، ناپایداری محاسباتی است که معمولاً به دلایل زیر رخ می‌دهد:

1.  **مدل‌های غیرخطی:** قطعاتی مانند لامپ (LAMP) یا ابزارهای اندازه‌گیری (ولت‌متر AC) دارای مدل‌های ریاضی پیچیده‌ای هستند که می‌توانند باعث عدم همگرایی شبیه‌سازی شوند.
2.  **سوئیچینگ سریع:** تغییرات ناگهانی ولتاژ و جریان در لحظه آتش شدن ترایاک، محاسبات را برای شبیه‌ساز دشوار می‌کند.
3.  **دقت بیش از حد:** تنظیمات پیش‌فرض شبیه‌ساز برای حداکثر دقت تنظیم شده‌اند که بار پردازشی را به شدت بالا می‌برد.

### راه حل: بهینه‌سازی تنظیمات شبیه‌سازی

برای حل این مشکل، باید با "آسان گرفتن" محدودیت‌ها، به شبیه‌ساز کمک کنیم تا به یک راه‌حل پایدار برسد.

#### مسیر دسترسی به تنظیمات:

1.  از منوی بالای نرم‌افزار، روی **System** کلیک کنید.
2.  گزینه **Set Animation Options...** را انتخاب نمایید.
3.  در پنجره باز شده، به تب **SPICE Options** بروید.

#### تغییر مقادیر مورد نیاز:

در این بخش، ما تعادل بین دقت و پایداری را تنظیم می کنیم. فکر کنید موتور شبیه‌سازی پروتئوس یک دستیار بسیار دقیق ولی کمی وسواسی است. این تنظیمات به ما اجازه می‌دهند به این دستیار بگوییم: "لازم نیست اینقدر وسواس به خرج دهی، کمی راحت‌تر بگیر تا کار سریع‌تر و بدون مشکل پیش برود."

##### ۱. RELTOL (سطح دقت کلی)

* **فرض کنید...** این پارامتر مانند میزان زوم روی یک نقشه است.
* **توضیح:** به صورت پیش‌فرض، پروتئوس با زوم بسیار بالا (**0.001**) به مدار نگاه می‌کند و تلاش می‌کند کوچکترین جزئیات و بی‌دقتی‌ها را محاسبه کند. این کار بسیار زمان‌بر است و گاهی باعث می‌شود در جزئیات بی‌اهمیت گیر کند.
* **تغییر پیشنهادی (0.1):** ما با این تغییر به پروتئوس می‌گوییم: "کمی زوم را عقب ببر و به تصویر کلی نگاه کن. نیازی نیست هر ترک کوچک روی آسفالت را ببینی، فقط مسیر اصلی را دنبال کن." این کار باعث می‌شود شبیه‌سازی بسیار سریع‌تر و پایدارتر شود.

##### ۲. ABSTOL (حساسیت به جریان‌های ناچیز)

* **فرض کنید...** این پارامتر مانند فیلتر نویز یک میکروفون است.
* **توضیح:** به صورت پیش‌فرض، این فیلتر به قدری حساس است (**1e-012**) که حتی صدای پچ‌پچ در اتاق کناری را هم ضبط می‌کند. در مدار، این به معنای تلاش برای محاسبه جریان‌های بسیار ناچیز و بی‌اثری است که فقط پردازنده را مشغول می‌کنند.
* **تغییر پیشنهادی (1e-006):** ما با این تغییر به پروتئوس می‌گوییم: "صداهای پس‌زمینه و جریان‌های بسیار ضعیف را نادیده بگیر و فقط روی جریان‌های اصلی که در مدار ما تأثیرگذار هستند، تمرکز کن." این کار از محاسبات اضافی جلوگیری کرده و به پایداری کمک می‌کند.

##### ۳. Integration Method (روش حل مسئله)

* **فرض کنید...** این پارامتر مانند انتخاب سیستم تعلیق برای یک ماشین است.
* **توضیح:**
    * **پیش‌فرض TRAPEZOIDAL:** مانند یک سیستم تعلیق اسپرت و خشک است. برای جاده‌های صاف و هموار عالی عمل می‌کند، اما اگر به یک دست‌انداز بزرگ (یک رویداد سوئیچینگ سریع در مدار) برسد، کنترل خود را از دست داده و به شدت تکان می‌خورد.
    * **پیشنهادی GEAR:** مانند یک سیستم تعلیق نرم و آفرود است. شاید در جاده صاف کمی کندتر باشد، اما برای جذب شوک‌ها و عبور از مسیرهای ناهموار و پر از دست‌انداز (مدارهای سوئیچینگ) بسیار پایدارتر و قابل اطمینان‌تر است.
* **تغییر پیشنهادی (GEAR):** چون مدار دیمر ما پر از "دست‌اندازهای" الکتریکی است، ما سیستم تعلیق GEAR را انتخاب می‌کنیم تا شبیه‌سازی با ثبات کامل پیش برود.

با اعمال این تغییرات، شما به موتور شبیه‌سازی اجازه می‌دهید تا با دقت کمتری اما با پایداری بسیار بیشتری کار کند و از بروز خطاهای مربوط به همگرایی جلوگیری شود.